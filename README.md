## Домашняя работа №1

### Задание №1
Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает.

HTTP-метод OPTIONS используется для определения параметров соединения с целевым ресурсом.
Адресс запроса может быть определенным URL или * для сервера целиком. Информация с поддерживаемыми методами содержиться в хедере `Allow`.

```
OPTIONS * HTTP/1.1
HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST // Доступные методы для запросов
Cache-Control: max-age=604800
Date: Thu, 13 Oct 2016 11:45:00 GMT
Expires: Thu, 20 Oct 2016 11:45:00 GMT
Server: EOS (lax004/2813)
x-ec-custom-error: 1
Content-Length: 0
```

По технологии CORS перед некоторыми запросами отправляется предварительный запрос, в ответ на это приходит информация о приемлимости отправки этим методом. Однако эти запросы отправляются самостоятельно браузером, и нет возможности установить хедер `Authorization`. Поэтому нужно реализовывать обработку OPTIONS запроса для авторизованного и неавторизованного пользователя. В первом случае мы будем принимать во внимание права текущего пользователя, а во втором мы будем должны вернуть все допустимые методы. Информация о предстоящем запросе содержиться в хедерах `Access-Control-Request-Method` и `Access-Control-Request-Headers`, в первом идут методы, а во втором о дополнительных хедерах.
```
OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST // Этот запрос идет перед POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type // Эти заголовки будут содержаться в следующем запросе
```
Ответ сервера содержит заголовки `Access-Control-Allow-Methods` и `Access-Control-Allow-Headers`, в первом говориться о доступных HTTP-методов, а во втором какие кастомные заголовки можно использовать в запросе.
```
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS // Запрашиваемый путь поддерживает эти методы
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // При запросе на этот адресс можно использовать эти дополнительные хедеры
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

### Задание №2
Прочитать и описать ключевые особенности "HTTP" Версии 3.0

Основная особенность HTTP 3.0 является переход с TCP на QUIC. Различия между этими протоколами заключаются в четырех пунктах:
1. QUIC глубоко интегрирован с TLS.

Это означает стирание четких границ между уровнями протоколов. Отказ от не защищенных соединений, более глубокое шифрование.
2. QUIC поддерживает несколько независимых потоков байтов.

В отличии от TCP файлы не объединяются в один большой, делая потоки их передачи независимыми от друг друга. При таком подходе потеря одного пакета не приводить к блокировки всего соединения, а блокируется только поток с потерянными данными.
3. QUIC использует идентификаторы соединений

Кроме стандартных параметров соединения, ip и портов клиента и сервера, добавляется идентификатор соединения CID. По нему клиент и сервер знают, какой CID с каким соединением связан, чтобы соединение можно было не разрывать.
4. QUIC использует фреймы

В отличии пакетов TCP, фреймы QUIC можно настравивать, согласовать используемые функции и передавать важные параметры по умолчанию для некоторых механизмов. В стандарте QUIC определён длинный список таких параметров, но можно определять и новые, что делает протокол ещё более гибким.

### Задание №3
Прочитать про способы отмены запроса, включая объект "AbortController"

#### Способы отмены
1. XMLHttpRequest
    ```
    const xhr = new XMLHttpRequest(); // Создание инстанса класса XMLHttpRequest
    xhr.open('GET', '/1.json'); // Конфигурация
    xhr.send(); // Отправка запроса
    xhr.abort(); // Отмена запроса
2. fetch через AbortController
    ```
    const controller = new AbortController(); // Создание инстанса класса AbortController
    fetch('localhost:3000', // Отправка запроса
      { signal: controller.signal } // Поле signal позволяет коммуницировать с fetch запросом, и если нужно отменить его
    );
    controller.abort(); // Отмена запроса
3. fetch через AbortSignal.timeout
    ```
    fetch('localhost:3000', // Отправка запроса
      { signal: AbortSignal.timeout(1000) }); // AbortSignal.timeout() автоматически отменяет запрос по истечению таймаута
4. axios через CancelToken
    ```
    const source = axios.CancelToken.source();
    axios.get('localhost:3000', // Отправка запроса
      { cancelToken: source.token } // Токен отмены аналог signal
    ).catch((e) => {
      if (axios.isCancel(e)) { // isCancel определяет была ли отмена запроса
        console.log('Request canceled', e.message);
      } else {
        // Обработка ошибки
      }
    });
    source.cancel('Request canceled due to timeout'); // Отмена запроса (указывать сообщение необязательно)
5. axios через AbortController
    ```
    const controller = new AbortController(); // Создание инстанса класса AbortController
    axios.get('localhost:3000',
      { signal: controller.signal } // Работает так же как и у fetch
    );
    controller.abort(); // Отмена запроса
6. axios через AbortSignal.timeout
    ```
    axios.get('/data.json',
      { signal: AbortSignal.timeout(1000) } // Работает так же как и у fetch
    );
    ```

#### Про AbortController
Контроллер позволяет при необходимости обрывать один и более DOM запросов.

Поля объекта
* signal — Возвращает экземпляр AbortSignal, который может быть использован для коммуникаций остановки DOM запросов.
* abort() – Прерывает DOM запрос.

### Задание №4
Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)

1. string
    ```
    const str1 = "hello";
    const str2 = `3 + 4 = ${ 3 + 4}`;
2. number
    ```
    const int1 = 12;
    const int2 = 0x124;
3. boolean
    ```
    const bool1 = true;
    const bool2 = Number.isNaN(NaN) || Array.isArray("");
4. null
    ```
    const null1 = null;
    const null2 = null;
5. undefined
    ```
    let undf1;
    const undf2 = [][0];
6. symbol
    ```
    const sym1 = Symbol('max');
    const sym2 = Symbol('length');
7. bigInt
    ```
    const bigInt1 = 9007199254740991n;
    const bigInt2 = BigInt(9007199254740991);
    ```

### Задание №5
Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?

Момент обращения находиться во временной мертвой зоне, то есть в промежутке времени с момента начала выполения программы до инициализации переменных.

### Задание №6
Что будет выведено в консоль в следующих примерах и почему?

1. `const res = "B" + "a" + (1 - "hello");`
* #### Первая операции `1 - "hello"`
    Так как это вычитание строка будет приводиться к числу, и будет равна `NaN`, потому что первый символ не число и начало не 16-ти разрядного числа. По итогу скобка равна `1 - NaN = NaN`, арифметических операции с `NaN` всегда равны `NaN`.
* #### Втора операция `"B" + "a"`
    При сложении строк происходить их объединение, и результатом будет `"Ba"`
* #### Третья операция `"Ba" + NaN`
    При сложении двух разных типов аргументов, происходить приведение одного к друго. В данном случае `NaN` будет приводиться к строке и будет равен `"NaN"`. Так что в результате будет `"Ba" + "NaN"` и будет происходить по логике описанной выше, и будет равно `"BaNaN"`
2. `const res2 = (true && 3) + "d";`
* #### Первая операции `true && 3`
    Логическое И работает по следующему принципу, происходит поиск с лева на право первого ложного аргумента, при нахождение такого возвращается его исходное значение, если такого нету, то возвращается исходное значение последнего аргумента. Так как `true` и `3` являются истинными, возвращается `3`;
* #### Втора операция `3 + "d"`
    В данном случае число будет приводиться к строке и объединяться со строкой, и будет равен `"3d"`
3. `const res3 = Boolean(true && 3) + "d";`
* #### Первая операции `true && 3`
    Аналогично предыдущему примеру, будет возвращено `3`
* #### Втора операция `Boolean(3)`
    Здесь происходит явное приведение типов, а именно `3` к его эквиваленту в булевом варианте, результатом этой операции будет `true`. Так как аргумент не равен ни одному значению из следующего списка: 0, -0, null, false, NaN, undefined, пустой аргумент, "".
* #### Третья операция `true + "d"`
    В этом случае булевый аргумент будет приводиться к строковому типу, и объединяться со строкой. В результате получаем `"true" + "d" = "trued"`
